# 快速排序

> 各个版本的源代码可见：[Github Repo](https://github.com/wxyyxc1992/just-coder-handbook/tree/master/ProgrammingParadigm/Algorithm/Sorting/src/main/java/wx/sorting/quick)

## Complexity: 算法复杂度

在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行 n‐1 次递归调用，且第 i 次划分需要经过 n‐i 次关键字的比较才能找到第 i 个记录，也就是枢轴的位置，因此比较次数为[![img](http://images.51cto.com/files/uploadimg/20110826/222653304.jpg)](http://images.51cto.com/files/uploadimg/20110826/222653304.jpg) ，最终其时间复杂度为 O(n2)。

平均的情况，设枢轴的关键字应该在第 k 的位置(1≤k≤n )，那么: ![](http://images.51cto.com/files/uploadimg/20110826/222801489.jpg)

由数学归纳法可证明，其数量级为 O(nlogn)。

就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为 log2n，其空间复杂度也就为 O(logn)，最坏情况，需要进行 n‐1 递归调用，其空间复杂度为 O(n)，平均情况，空间复杂度也为 O(logn)。

可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。

其实这个空间复杂度不太好计算，因为有的人使用的是非就地排序，那样就不好计算了(因为有的人用到了辅助数组，所以这就要计算到你的元素个数了)；我就分析下就地快速排序的空间复杂度吧； 首先就地快速排序使用的空间是 O(1) 的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据； 最优的情况下空间复杂度为：O(logn) ；每一次都平分数组的情况

最差的情况下空间复杂度为：O( n ) ；退化为冒泡排序的情况

### 稳定性

快速排序有两个方向，左边的 i 下标一直往右走，当 a[i] <= a[center_index]，其中 center_index 是中枢元素的数组下标，一般取为数组第 0 个元素。而右边的 j 下标一直往左走，当 a[j]

> a[center_index]。如果 i 和 j 都走不动了，i <= j ，交换 a[i]和 a[j], 重复上面的过程，直到 i > j。 交换 a[j]和 a[center_index]，完成一趟快速排序。在中枢元素和 a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11，现在中枢元素 5 和 3(第 5 个元素，下标从 1 开始计)交换就会把元素 3 的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和 a[j] 交换的时刻。

## Implementation: 代码实现

```java
package wx.sorting.quick;

import java.util.Arrays;

/**
 * @function:<p>实现快速排序算法</p>
 */
public class QuickSort {

    /**
     * 划分
     *
     * @param arr
     * @param left
     * @param right
     * @return
     */
    public static int partition(int[] arr, int left, int right) {

        //选定左侧的为标杆
        int pivotKey = arr[left];


        while (left < right) {

            //从右侧开始,寻找到第一个小于标杆的数
            while (left < right && arr[right] >= pivotKey)
                right--;

            //把小的移动到左边
            arr[left] = arr[right];

            //从左侧开始,寻找到第一个大于标杆的数
            while (left < right && arr[left] <= pivotKey)
                left++;

            //把大的移动到右边
            arr[right] = arr[left];
        }

        //到这里left和right必然重合
        assert left == right;

        //最后把pivot赋值到中间
        arr[left] = pivotKey;

        return left;
    }

    /**
     * 递归划分子序列
     *
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort(int[] arr, int left, int right) {

        //判断是否只剩下最后一个数了
        if (left >= right)
            return;

        //如果还有多个数,则先进行划分,划分的结果即是左侧肯定比右侧小
        int pivotPos = partition(arr, left, right);

        //对于左侧进行排序
        quickSort(arr, left, pivotPos - 1);

        //对于右侧进行排序
        quickSort(arr, pivotPos + 1, right);

    }

    public static void sort(int[] arr) {

        //判断字符串是否为空或者长度是否为0
        if (arr == null || arr.length == 0)
            return;

        //进行全部的快速排序
        quickSort(arr, 0, arr.length - 1);
    }

    public static void main(String args[]) {

        int[] arr = new int[]{3, 9, 7, 8, 5, 11, 32};

        QuickSort.sort(arr);

        for(int a : arr){
            System.out.println(a);
        }

    }

}
```

# 归并排序

归并排序是建立在归并操作上的一种有效的排序算法 , 该算法是采用分治法(Divide and Conquer )的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 基本思路: 先递归的把数组划分为两个子数组，一直递归到数组中只有一个元素，然后再调用函数把两个子数组排好序，因为该函数在递归划分数组时会被压入栈，所以这个函数真正的作用是对两个有序的子数组进行排序； 基本步骤: 1 、判断参数的有效性，也就是递归的出口； 2 、首先什么都不管，直接把数组平分成两个子数组； 3 、递归调用划分数组函数，最后划分到数组中只有一个元素，这也意味着数组是有序的了； 4 、然后调用排序函数，把两个有序的数组合并成一个有序的数组；

5 、排序函数的步骤，让两个数组的元素进行比较，把大的 / 小的元素存放到临时数组中，如果有一个数组的元素被取光了，那就直接把另一数组的元素放到临时数组中，然后把临时数组中的元素都复制到实际的数组中；

## Complexity: 复杂度分析

归并的时间复杂度分析：主要是考虑两个函数的时间花销，一、数组划分函数 mergeSort()；二、有序数组归并函数 \_mergeSort()；

\_mergeSort() 函数的时间复杂度为 O(n)，因为代码中有 2 个长度为 n 的循环(非嵌套)，所以时间复杂度则为 O(n)；

简单的分析下元素长度为 n 的归并排序所消耗的时间 T[n]：调用 mergeSort() 函数划分两部分，那每一小部分排序好所花时间则为 T[n/2]，而最后把这两部分有序的数组合并成一个有序的数组 \_mergeSort() 函数所花的时间为 O(n)；

公式：T[n] = 2T[n/2] + O(n) ；

公式就不仔细推导了，可以参考下: 排序算法之快速排序及其时间复杂度和空间复杂度里面时间复杂度的推导；

所以得出的结果为：T[n] = O( nlogn )

因为不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：O( nlogn ) ；好像有人说最差的时间复杂度不是 O(nlogn)，我不知道怎么算出来的，知道的麻烦告知下，谢谢；归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n + logn ；所以空间复杂度为 : O(n)

我看到网上很多 blog 分享空间复杂度只有 O(1) 的归并排序法；因为传统的归并排序所消耗的空间主要是在归并函数(把两个有序的函数合并成一个有序的函数)，所以如果要让时间复杂度为 O(1) ，那么也只能在归并函数中做文章了。代码就不列出来了，其主要思想就是借助于快速排序(其实就是相当于归并函数被快速排序函数替换了)；这样的方法虽然可以减少内存的消耗，但是却会在时间上带来损失，因为这样时间复杂度却变成了 O(n^2) 了；所以这种方法并不是一个两全其美的 idea；

### 稳定性

归并排序是把序列递归地分成短序列，递归出口是短序列只有 1 个元素(认为直接有序)或者 2 个序列(1 次比较和交换)，然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在 1 个或 2 个元素时，1 个元素不会交换，2 个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。

## Implementation: 代码实现

# 堆排序

堆排序 (Heapsort) 是指利用堆积树(堆)这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大顶堆和小顶堆，是完全二叉树。大顶堆的要求是每个节点的值都不大于其父节点的值，即 A[PARENT[i]] >= A[i]。在数组的升序排序中，需要使用的就是大顶堆，因为根据大顶堆的要求可知，最大的值一定在堆顶。那么依次把这个最大值交换到数组尾部，即可完成一个升序排列的过程。堆排序的一个优势在于可以只对某个较大的数组中的前 K 个进行排序，譬如从 N 个无序的整数中计算机最小的 K 个整数的算法，并给出时间复杂度，其中 K<<N，要求时间复杂度尽可能的低，不要求 K 个整数排序。将 N 个数中的前 K 个建立一个小顶堆。每读入一个新的整数，就把它插入到堆中，调整堆，但是每次调整都只调整前 K 个元素。从第 K+1 个位置开始的元素都忽略。时间为 NlogK。

## Complexity: 算法复杂度

### 稳定性

我们知道堆的结构是节点 i 的孩子为 2 _ i 和 2 _ i + 1 节点，大顶堆要求父节点大于等于其 2 个子节点，小顶堆要求父节点小于等于其 2 个子节点。在一个长为 n 的序列，堆排序的过程是从第 n / 2 开始和其子节点共 3 个值选择最大(大顶堆)或者最小(小顶堆)，这 3 个元素之间的选择当然不会破坏稳定性。但当为 n / 2 - 1， n / 2 - 2 ， ... 1 这些个父节点选择元素时，就会破坏稳定性。有可能第 n / 2 个父节点交换把后面一个元素交换过去了，而第 n / 2 - 1 个父节点把后面一个相同的元素没 有交换，那么这 2 个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。

## 堆

堆(也叫优先队列)，是一棵完全二叉树，它的特点是父节点的值大于(小于)两个子节点的值(分别称为大顶堆和小顶堆)。它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足二个特性：

* 父结点的键值总是大于或等于(小于或等于)任何一个子节点的键值。
* 每个结点的左子树和右子树都是一个二叉堆(都是最大堆或最小堆)。

当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。下图展示一个最小堆：

![](http://hi.csdn.net/attachment/201108/22/0_1314014666d5oe.gif)

堆的存储上一般都用数组来表示堆，i 结点的父结点下标就为 (i – 1) / 2。它的左右子结点下标分别为 2 _ i + 1 和 2 _ i + 2。如第 0 个结点左右子结点下标分别为 1 和 2。

![](http://hi.csdn.net/attachment/201108/22/0_1314014706gZqn.gif)

## 堆建立

操作主要是将数组 A 转化成一个大顶堆。思想是，先找到堆的最后一个非叶子节点(即为第 n/2 个节点)，然后从该节点开始，从后往前逐个调整每个子树，使之称为堆，最终整个数组便是一个堆。子数组 A[(n/2)+1..n]中的元素都是树中 的叶子，因此都可以看作是只含有一个元素的堆。 ![](http://hi.csdn.net/attachment/201108/22/0_1314014725K5k6.gif) 很明显，对叶子结点来说，可以认为它已经是一个合法的堆了即 20，60 ， 65， 4 ， 49 都分别是一个合法的堆。只要从 A[4]=50 开始向下调整就可以了。然后再取 A[3]=30，A[2] = 17 ， A[1] = 12，A[0] = 9 分别作一次向下调整操作就可以了。下图展示了这些步骤: ![](http://hi.csdn.net/attachment/201108/22/0_1314014735kbBA.gif)

## 堆排序

“ 空间复杂度 ” 指占内存大小，堆排序每次只对一个元素操作，是就地排序，所用辅助空间 O(1)，空间复杂度是 O(1 )

在构建堆的过程中，完全二叉树从最下层最右边的非终端结点开始构建，将它与其孩子进行比较和必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为 O(n)。 在正式排序时，第 i 次取堆顶记录重建堆需要用 O(logi) 的时间(完全二叉树的某个结点到根结点的距离为 ⌊log2i⌋+1)，并且需要取 n-1 次堆顶记录，因此，重建堆的时间复杂度为 O(nlogn)。首先可以看到堆建好之后堆中第 0 个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第 0 个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。由于堆也是用数组模拟的，故堆化数组后，第一次将 A[0]与 A[n - 1]交换，再对 A[0…n-2]重新恢复堆。第二次将 A[0]与 A[n – 2]交换，再对 A[0…n - 3]重新恢复堆，重复这样的操作直到 A[0]与 A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。有点类似于直接选择排序。

完整的实例代码如下：

```
package wx.sorting.heap;

import wx.sorting.quick.QuickSort;

/**
 * Created by apple on 16/4/23.
 */
public class HeapSort {

    /**
     * 堆筛选，除了start之外，start~end均满足大顶堆的定义。
     * 调整之后start~end称为一个大顶堆。
     *
     * @param arr   待调整数组
     * @param start 起始指针
     * @param end   结束指针
     */
    public static void heapAdjust(int[] arr, int start, int end) {

        int temp = arr[start];

        //这里需要重复交换是因为将父节点交换给子节点之后,子节点所处的堆可能就不是大顶堆了,所以需要递归的来调整
        for (int i = 2 * start + 1; i <= end; i *= 2) {

            //左右孩子的节点分别为2*i+1,2*i+2

            //选择出左右孩子较大的下标
            if (i < end && arr[i] < arr[i + 1]) {
                i++;
            }

            if (temp >= arr[i]) {
                break; //已经为大顶堆，=保持稳定性。
            }

            arr[start] = arr[i]; //将子节点上移

            start = i; //下一轮筛选
        }

        arr[start] = temp; //插入正确的位置
    }

    /**
     * @param arr
     * @function 进行堆排序操作
     */
    public static void heapSort(int[] arr) {

        //首先根据输入的序列构造大顶堆,即把值最大的元素移到堆顶

        //从第一个非子节点开始调整
        //这里需要从子节点循环调用的原因是,只有到两个子节点所在的子堆已经是最大堆了,才能保证父节点与其子节点比较后就能保证把全局最大的元素替换上来
        for (int i = arr.length / 2; i >= 0; i--) {

            //这里调整当前非子节点与其子节点
            heapAdjust(arr, i, arr.length - 1);
        }

        System.out.println("大顶堆为:");

        for (int a : arr) {
            System.out.print(a + "  ");
        }

        //不断将堆顶值放入有序区,并且重复对无序区进行大顶堆修正
        for (int i = arr.length - 1; i >= 0; i--) {

            //把值最大的放到最后一个叶子节点处,即放入有序区中
            swap(arr, 0, i);

            //调整无序区的结构,使之成为大顶堆
            heapAdjust(arr, 0, i - 1);

        }

    }

    //交换左右的数
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String args[]) {

        int[] arr = new int[]{3, 9, 7, 8, 5, 11, 32};

        HeapSort.heapSort(arr);

        System.out.println("排序后的数组为:");

        for (int a : arr) {
            System.out.print(a + "  ");
        }

    }

    /**
     *  大顶堆为:
     32  9  11  8  5  3  7
     排序后的数组为:
     3  5  7  8  9  11  32
     */

}
```

# Bucket Sorting: 桶排序

>

* [经典排序算法 - 桶排序 Bucket sort](http://www.cnblogs.com/kkun/archive/2011/11/23/2260267.html)
