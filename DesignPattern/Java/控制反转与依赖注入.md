# ä¾èµ–æ³¨å…¥ä¸æ§åˆ¶åè½¬

Martin Fowler åœ¨ 2004 å¹´å‘è¡¨çš„ [Inversion of Control Containers and the Dependency Injection pattern](https://martinfowler.com/articles/injection.html) ä¸€æ–‡ä¸­é˜è¿°äº† IoC çš„æ¦‚å¿µä¸å®è·µæ¨¡å¼ã€‚

åœ¨ä¼ ç»Ÿçš„å±‚æ¬¡åŒ–æ¨¡å¼ï¼ˆLayers Patternï¼‰ä¸­ï¼Œé«˜å±‚æ¬¡çš„ç»„ä»¶(Higher Level)è°ƒç”¨ä½å±‚æ¬¡ï¼ˆLower Levelï¼‰çš„ç»„ä»¶æ¥é€æ­¥æ„å»ºå¤æ‚çš„ç³»ç»Ÿï¼›ä¸è¿‡è¿™ç§æ–¹å¼ä¼šå¯¼è‡´ç»„ä»¶ä¹‹é—´å­˜åœ¨è¾ƒå¼ºçš„è€¦åˆï¼Œå¯¹äºä½å±‚æ¬¡ç»„ä»¶çš„å¼ºä¾èµ–å¾€å¾€ä¹Ÿä¼šé™åˆ¶äº†é«˜å±‚æ¬¡ç»„ä»¶çš„å¯æ‰©å±•æ€§ä¸é‡ç”¨æ€§ã€‚

# Web ç»„ä»¶

ä¾èµ–æ³¨å…¥çš„æ¦‚å¿µæœ€æ—©ç”± Google Angular å¼•å…¥åˆ° Web å‰ç«¯ç¼–ç ä¸­ï¼Œè€Œéšç€ç»„ä»¶åŒ–æ¦‚å¿µçš„æµè¡Œï¼Œç‰¹åˆ«æ˜¯ç±»ç»„ä»¶çš„æ–¹å¼é€æ­¥æˆä¸ºä¸»æµï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨å‰ç«¯ç¼–ç ä¸­å®è·µä¾èµ–æ³¨å…¥æˆ–è€…æ§åˆ¶åè½¬çš„æ¨¡å¼ã€‚

æ§åˆ¶åè½¬å¹¶éå¤šä¹ˆå¤æ‚çš„æ¨¡å¼ï¼Œæˆ‘ä»¬å¯ä»¥å°†é‚£äº›é€šè¿‡ Props ä¼ å…¥çš„ Every function passed in via props is an â€œinjection of a dependencyâ€, and every component that declares a prop for handling events or user interaction is observing â€œinversion of controlâ€. The borrowed terms have now been rendered obsolete through ubiquity, save perhaps for use as shibboleth for JavaScripters who have lived through the reign of Angular.

#### ype 3 IoCâ€Šâ€”â€ŠConstructor Injection

As the name implies, this component would receive its dependencies via the constructor. Hereâ€™s what such a component would look like:

```
class Knight extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      weapon: props.weapon
    };
  }
  render() {
    return `ğŸ´ ${this.state.weapon}`;
  }
}
```

And you would use it like this:

```
<Knight weapon={sword} />
```

Of course, you should typically use the prop directly instead of duplicating it.

#### Type 2 IoCâ€Šâ€”â€ŠSetter Injection

Instead of setting dependencies in the constructor, a component would have methods available that can be called after initialization, with dependencies passed in as the argument.

```
class Knight extends React.Component {
  state = {};
  setWeapon = (weapon) => this.setState({ weapon });
  render() {
    return `ğŸ´ ${this.state.weapon}`;
  }
}
```

Usage:

```
componentDidMount () {
  this.knight.setWeapon(sword);
}
render () {
  return <Knight ref={c => this.knight = c} />;
}
```

Again, you almost certainly would not want do this instead of passing dependencies directly via props.

#### Type 1 IoCâ€Šâ€”â€ŠInterface Injection

The props of a component are its interface to its clients, thus â€œrequired propsâ€ would come the closest to an analogy for interface injection with React:

```
class Knight extends React.Component {
  static propTypes = {
    weapon: PropTypes.any.isRequired
  };
  render() {
    return `ğŸ´ ${this.props.weapon}`;
  }
}
```

and you would use it simply as

```
<Knight weapon={sword} />
```

I hope these examples illustrate how commonplace Dependency Injection has become, and gave you some talking points should the topic ever comes up.
